##########################################################################
#                                                                        #
#  Menhir                                                                #
#                                                                        #
#  François Pottier and Yann Régis-Gianas, INRIA Rocquencourt            #
#                                                                        #
#  Copyright 2005 Institut National de Recherche en Informatique et      #
#  en Automatique. All rights reserved. This file is distributed         #
#  under the terms of the Q Public License version 1.0, with the         #
#  change described in file LICENSE.                                     #
#                                                                        #
##########################################################################

# -*- Makefile -*- 
# -------------------------------------------------------------------------

.PHONY: clean demos

COLD         += clean demos

# ----------------------------------------------------------------------------
# Locating the ocaml compilers.
# If ocamlfind is available, then it is used for that purpose.

CAMLTOP         := ocaml

CAMLC           := $(shell if ocamlfind ocamlc -v >/dev/null 2>&1 ; \
                       then echo ocamlfind ocamlc ; \
		       elif ocamlc.opt -v >/dev/null 2>&1 ; \
                       then echo ocamlc.opt ; \
		       else echo ocamlc ; fi)

CAMLOPT         := $(shell if ocamlfind ocamlopt -v >/dev/null 2>&1 ; \
                       then echo ocamlfind ocamlopt ; \
		       elif ocamlopt.opt -v >/dev/null 2>&1 ; \
                       then echo ocamlopt.opt ; \
		       else echo ocamlopt ; fi)

CAMLDEP         := $(shell if ocamlfind ocamldep -version >/dev/null 2>&1 ; \
                       then echo ocamlfind ocamldep ; \
		       elif ocamldep.opt -version >/dev/null 2>&1 ; \
                       then echo ocamldep.opt ; \
		       else echo ocamldep ; fi)

CAMLLEX         := ocamllex

CAMLYACC        := ocamlyacc -v

# -------------------------------------------------------------------------

# Compilation flags.

BFLAGS       := -g
OFLAGS       := -compact
LNKBFLAGS    := -g unix.cma
LNKOFLAGS    := unix.cmxa
PGFLAGS      := -v -lg 1 -la 1 -lc 1 --comment --infer --error-recovery --stdlib .

# -------------------------------------------------------------------------

# A list of the source files that must be generated.

GENERATED    := stdlib.ml lexmli.ml lexer.ml parser.mli parser.ml lineCount.ml lexdep.ml

# -------------------------------------------------------------------------

# A list of the modules that must be linked in.

MODULES      :=								\
   stringSet stringMap mark compressedBitSet unionFind tarjan patricia	\
   infiniteArray misc option breadth listMonad dot			\
   stdlib version settings time positions error				\
   parameters keyword lineCount printer action parserAux parser lexer	\
   partialGrammar parameterizedGrammar reachability			\
   unparameterizedPrinter preFront					\
   codeBits tokenType interface IO lexmli lexdep infer			\
   nonTerminalDefinitionInlining front					\
   grammar item lr0 lr1 lr1partial derivation conflict		        \
   invariant code traverse inliner back

OBJECTS      := $(MODULES:=.cmo)
XBJECTS      := $(MODULES:=.cmx)

# -------------------------------------------------------------------------

# How to bootstrap. Set TARGET to byte or opt depending on the desired
# architecture. In either case, the resulting executable is named
# menhir.

ifndef TARGET
  TARGET     := opt
endif

GOAL         := menhir.$(TARGET)

menhir: .versioncheck
# Build a stage one executable using ocamlyacc.
	$(MAKE) $(MFLAGS) -s PGEN="$(CAMLYACC)" PARSER=parser $(GOAL)
# Remove the ocamlyacc-built parser.
	@/bin/rm -f parser.ml parser.mli
# Build a stage two executable using the stage one executable (which is overwritten).
	$(MAKE) $(MFLAGS) -s PGEN="./$(GOAL) $(PGFLAGS)" PARSER=fancy-parser $(GOAL)
# Create a stage three parser and make sure that it is identical.
	@./$(GOAL) $(PGFLAGS) -b reference fancy-parser.mly 2>/dev/null
	@if diff parser.mli reference.mli 2>&1 >/dev/null ; then \
	  if diff parser.ml reference.ml 2>&1 >/dev/null ; then \
	    echo "Bootstrap successful." ; \
	  else \
	    echo "Bootstrap FAILED: the implementation files differ." && false ; \
          fi ; \
	else \
	  echo "Bootstrap FAILED: the interface files differ." && false ; \
	fi
	@rm -f reference.{ml,mli}
# Rename the stage two executable to the desired name.
	@ln $(GOAL) menhir

# -------------------------------------------------------------------------

# Linking.

menhir.byte: $(OBJECTS)
	$(CAMLC) -o $@ $(LNKBFLAGS) $(OBJECTS)

menhir.opt: $(XBJECTS)
	$(CAMLOPT) -o $@ $(LNKOFLAGS) $(XBJECTS)

# -------------------------------------------------------------------------

# Computing dependencies. This can be done in a simple way, even though
# we exploit --infer, because we compile in two stages. Not a good example
# of how to do it yourself -- have a look at demos/Makefile.shared.

.depend: $(wildcard *.ml *.mli) $(GENERATED)
	@/bin/rm -f .depend
	$(CAMLDEP) *.ml *.mli > $@

ifeq ($(findstring $(MAKECMDGOALS),$(COLD)),)
-include .depend
endif

# -------------------------------------------------------------------------

# Cleaning up.

clean::
	/bin/rm -f menhir.byte menhir.opt menhir
	/bin/rm -f *.cmi *.cmx *.cmo *.o *.obj *~ .*~
	/bin/rm -f reference.ml reference.mli $(GENERATED)
	/bin/rm -f .depend *.conflicts *.automaton *.annot

# -------------------------------------------------------------------------

# Compiling. The parser source is found in $(PARSER).mly and is
# processed using $(PGEN).

# These two default definitions really shouldn't be necessary, but
# there are corner cases where they are needed (e.g. when make is
# invoked without a target and the .depend file is regenerated).

ifndef PGEN
  PGEN       := $(CAMLYACC)
endif
ifndef PARSER
  PARSER     := parser
endif

%.cmi: %.mli
	$(CAMLC) $(BFLAGS) -c $<

%.cmo: %.ml
	$(CAMLC) $(BFLAGS) -c $<

%.cmx %.o: %.ml
	$(CAMLOPT) $(OFLAGS) -c $<

parser.ml parser.mli: $(PARSER).mly
	@/bin/rm -f parser.ml parser.mli
	$(PGEN) -b parser $<
	@/bin/chmod -w parser.ml parser.mli

%.ml: %.mll
	@/bin/rm -f $@
	$(CAMLLEX) $<
	@/bin/chmod -w $@

# -------------------------------------------------------------------------

# Making the demos.

demos:
	$(MAKE) $(MFLAGS) MENHIR="../../$(MENHIR)" -C demos

clean::
	$(MAKE) $(MFLAGS) -C demos $@

# ----------------------------------------------------------------------------
# Checking the version of the ocaml compiler.
#
# We check the bytecode compiler only, because some architectures don't have
# the native code compiler. We assume that both compilers, if present, are in
# sync.

.versioncheck:
	@ echo Checking that Objective Caml is recent enough...
	@ $(CAMLTOP) str.cma check-ocaml-version.ml --verbose --gt "3.09"
	@ touch .versioncheck

clean::
	rm -f .versioncheck

